
#ifndef AST_H
#define AST_H

#include "general.h"
#include "lexer.h"

struct Atom;
struct Ast_Declaration;
struct Ast_Function;
struct Ast_Type_Info;
struct Ast_Identifier;
struct Ast_Scope;
struct Ast_Struct;

enum Ast_Type {
    AST_UNINITIALIZED,
    AST_BINARY_EXPRESSION,
    AST_UNARY_EXPRESSION,
    AST_IDENTIFIER,
    AST_DECLARATION,
    AST_SCOPE,
    AST_FUNCTION,
    AST_LITERAL,
    AST_FUNCTION_CALL,
    AST_DEREFERENCE,
    AST_CAST,
    AST_IF,
    AST_WHILE,
    AST_RETURN,
    AST_TYPE_INSTANTIATION,
    AST_TYPE_ALIAS,
    AST_ARRAY_DEREFERENCE,
    AST_SIZEOF,
    AST_FOR,
    AST_STRUCT,
    AST_DIRECTIVE_LOAD,
    AST_DIRECTIVE_STATIC_IF,
    AST_SCOPE_EXPANSION,
    AST_OS,
};

struct Ast {
    TextSpan text_span;
    String filename;
    
    Ast_Type type;
};

struct Ast_Type_Info {
    enum Type {
        UNINITIALIZED = 0,
        
        // primitves
        VOID,
        BOOL,
        INTEGER,
        FLOAT,
        STRING,
        
        // non-primitves
        POINTER,
        ARRAY,
        ALIAS,
        FUNCTION,
        TYPE, // meta type assigned to typealias and struct
        
        // User defined (mostly)
        STRUCT,
    };
    
    Type type = UNINITIALIZED;
    
    
    bool is_signed = false; // for INTEGER
    
    Ast_Type_Info *pointer_to    = nullptr;
    Ast_Type_Info *alias_of      = nullptr;
    Ast_Type_Info *array_element = nullptr;
    
    array_count_type array_element_count = -1;
    bool is_dynamic = false; // for array
    
    Ast_Struct *struct_decl = nullptr;
    // @Cleanup hmm... is this really necessary? Should we just have all type code just check struct_decl? or is that overstepping what the type information is for..?
    struct Struct_Member {
        Atom *name               = nullptr;
        s64 element_index        = -1;
        Ast_Type_Info *type_info = nullptr;
        bool is_let = false;
    };
    Array<Struct_Member> struct_members; // for STRUCT
    
    // FUNCTION
    Array<Ast_Type_Info *> arguments;
    Ast_Type_Info *return_type = nullptr;
    bool is_c_function = false;
    bool is_c_varargs  = false;
    
    s64 stride = -1;
    s64 alignment = -1;
    s64 size = -1;
};

struct Ast_Expression : Ast {
    Ast_Type_Info *type_info = nullptr;
    
    Ast_Expression *substitution = nullptr;
};

struct Ast_Scope : Ast_Expression {
    Ast_Scope() { type = AST_SCOPE; }
    Ast_Scope *parent = nullptr;
    Array<Ast_Expression *> statements;
    Array<Ast_Expression *> declarations; // really should only contain Ast_Declaration and Ast_Function
    
    bool is_template_argument_block = false;
    bool rejected_by_static_if = false;
    
    Ast_Struct *owning_struct = nullptr;
    
    // Ast_Function   *owning_function = nullptr;
    // Ast_Expression *owning_statement = nullptr;
};

// Used to specify a scope that was inserted due to the compiler resolving a static_if.
struct Ast_Scope_Expansion : Ast_Expression {
    Ast_Scope_Expansion() { type = AST_SCOPE_EXPANSION; }
    
    Ast_Scope *scope = nullptr;
};

struct Ast_Type_Instantiation : Ast_Expression {
    Ast_Type_Instantiation() { type = AST_TYPE_INSTANTIATION; }
    
    // @Cleanup maybe, builtin_primitive sort of overlaps with type_value since it is known at the time of parsing.
    Ast_Type_Info *builtin_primitive = nullptr;
    Ast_Type_Instantiation *pointer_to = nullptr;
    Ast_Identifier *typename_identifier = nullptr;
    
    Ast_Type_Instantiation *array_element_type = nullptr;
    Ast_Expression *array_size_expression = nullptr;
    bool array_is_dynamic = false;
    
    Ast_Function *function_header = nullptr;
    
    Ast_Type_Info *type_value = nullptr;
};

struct Ast_Type_Alias : Ast_Expression {
    Ast_Type_Alias() { type = AST_TYPE_ALIAS; }
    
    Ast_Identifier *identifier = nullptr;
    Ast_Type_Instantiation *internal_type_inst = nullptr;
    
    Ast_Type_Info *type_value = nullptr; // use this instead of internal_type_inst->type_value in case this typealias was generated by the compiler by template-instantiation.
};

struct Ast_Struct : Ast_Expression {
    Ast_Struct() { type = AST_STRUCT; }
    
    Ast_Identifier *identifier = nullptr;
    Ast_Scope member_scope;
    
    Ast_Type_Info *type_value = nullptr;
};

struct Ast_Unary_Expression : Ast_Expression {
    Ast_Unary_Expression() { type = AST_UNARY_EXPRESSION; }
    
    Token::Type operator_type;
    Ast_Expression *expression = nullptr;
};

struct Ast_Binary_Expression : Ast_Expression {
    Ast_Binary_Expression() { type = AST_BINARY_EXPRESSION; }
    
    Token::Type operator_type;
    Ast_Expression *left  = nullptr;
    Ast_Expression *right = nullptr;
};

struct Ast_Identifier : Ast_Expression {
    Ast_Identifier() { type = AST_IDENTIFIER; }
    Atom *name = nullptr;
    
    Ast_Scope *enclosing_scope = nullptr;
    
    Ast_Expression *resolved_declaration = nullptr;
    Array<Ast_Function *> overload_set;
};

struct Ast_Dereference : Ast_Expression {
    Ast_Dereference() { type = AST_DEREFERENCE; }
    
    Ast_Expression *left = nullptr;
    Ast_Identifier *field_selector = nullptr;
    
    s64 element_path_index = -1; // 0-based element into the list of declarations or fields within the outer type
    s64 byte_offset = -1; // byte-offset from the start of the the memory occupied by the outer type
};

struct Ast_Array_Dereference : Ast_Expression {
    Ast_Array_Dereference() { type = AST_ARRAY_DEREFERENCE; }
    
    Ast_Expression *array_or_pointer_expression = nullptr;
    Ast_Expression *index_expression = nullptr;
};

struct Ast_Function_Call : Ast_Expression {
    Ast_Function_Call() { type = AST_FUNCTION_CALL; }
    
    Ast_Expression *function_or_function_ptr = nullptr;
    Array<Ast_Expression *> argument_list;
};

struct Ast_If : Ast_Expression {
    Ast_If() { type = AST_IF; }
    
    Ast_Expression *condition = nullptr;
    
    Ast_Expression *then_statement = nullptr;
    Ast_Expression *else_statement = nullptr;
};

struct Ast_While : Ast_Expression {
    Ast_While() { type = AST_WHILE; }
    
    Ast_Expression *condition = nullptr;
    Ast_Expression *statement = nullptr;
};

struct Ast_Return : Ast_Expression {
    Ast_Return() { type = AST_RETURN; }
    
    Ast_Function *owning_function = nullptr;
    Ast_Expression *expression = nullptr;
};

struct Ast_Literal : Ast_Expression {
    Ast_Literal() { type = AST_LITERAL; }
    
    enum Type {
        INTEGER,
        STRING,
        FLOAT,
        BOOL,
        NULLPTR,
    };
    
    Type literal_type;
    
    bool bool_value;
    s64 integer_value;
    double float_value;
    String string_value;
};

struct Ast_Declaration : Ast_Expression {
    Ast_Declaration() { type = AST_DECLARATION; }
    Ast_Identifier *identifier = nullptr;
    Ast_Expression *initializer_expression = nullptr;
    
    Ast_Type_Instantiation *type_inst = nullptr;
    
    bool is_let = false;
    bool is_readonly_variable = false;
    bool is_struct_member = false;
};

struct Ast_Function : Ast_Expression {
    Ast_Function() { type = AST_FUNCTION; }
    
    Ast_Identifier *identifier;
    
    Array<Ast_Declaration *> arguments;
    Ast_Declaration *return_decl = nullptr;
    
    Ast_Scope *polymorphic_type_alias_scope = nullptr;
    Ast_Scope arguments_scope;
    Ast_Scope *scope = nullptr;
    
    Array<Ast_Function *> polymorphed_overloads;
    
    bool is_marked_metaprogram = false;
    bool is_c_function = false;
    bool is_c_varargs = false;
    bool is_template_function = false;
    
    String linkage_name;
    bool body_checked = false;
};

struct Ast_Cast : Ast_Expression {
    Ast_Cast() { type = AST_CAST; }
    Ast_Type_Instantiation *target_type_inst = nullptr;
    Ast_Expression *expression = nullptr;
};

struct Ast_Sizeof : Ast_Expression {
    Ast_Sizeof() { type = AST_SIZEOF; }
    Ast_Type_Instantiation *target_type_inst = nullptr;
};

struct Ast_Os : Ast_Expression {
    Ast_Os() { type = AST_OS; }
    
    Ast_Expression *expression = nullptr;
};

struct Ast_For : Ast_Expression {
    Ast_For() { type = AST_FOR; }
    
    Ast_Declaration *iterator_decl       = nullptr;
    Ast_Declaration *iterator_index_decl = nullptr;
    
    Ast_Expression *initial_iterator_expression = nullptr;
    Ast_Expression *upper_range_expression      = nullptr;
    
    Ast_Scope iterator_declaration_scope;
    Ast_Scope body;
};

struct Ast_Directive : Ast_Expression {
    
    Ast_Scope *scope_i_belong_to = nullptr;
};

struct Ast_Directive_Load : Ast_Directive {
    Ast_Directive_Load() { type = AST_DIRECTIVE_LOAD; }
    
    Ast_Scope *target_scope;
    String     target_filename;
};

struct Ast_Directive_Static_If : Ast_Directive {
    Ast_Directive_Static_If() { type = AST_DIRECTIVE_STATIC_IF; }
    
    Ast_Expression *condition = nullptr;
    
    Ast_Scope *then_scope = nullptr;
    Ast_Scope *else_scope = nullptr;
};


#define AST_NEW(type) (type *)ast_init(this, new type());

#endif
