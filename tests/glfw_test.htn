// htn stuff

typealias c_string = *uint8;

func c_style_strlen(input: c_string) -> int64 {
	var cursor = input;
	while <<cursor != 0 {
		cursor = cursor + 1;
	}

	return cast(int64) (cursor - input);
}

func to_string(input: c_string) -> string {
	var s: string;
	s.data   = input;
	s.length = c_style_strlen(input);
	return s;
}



// C library
func @c_function printf(fmt: *uint8, temporary_c_vararg);

typealias FILE = void;
func @c_function fopen(path: c_string, mode: c_string) -> *FILE;
func @c_function fclose(file: *FILE) -> int32;
func @c_function ftell(file: *FILE) -> int32; // long int, this should be int32 on Windows but s64 on Linux/Mac
func @c_function fread(ptr: *void, size: size_t, count: size_t, file: *FILE) -> size_t;

let SEEK_SET = 0;
let SEEK_CUR = 1;
let SEEK_END = 2;

func @c_function fseek(file: *FILE, offset: int32 /*long int*/, origin: int32);

typealias size_t = uint32; // @FixMe I dont know if this is right

func @c_function malloc(size: size_t) -> *void;
func @c_function free(ptr: *void);
func @c_function memcpy(dest: *void, src: *void, count: size_t);

// GLFW
func @c_function glfwInit();
func @c_function glfwCreateWindow(width: int32, height: int32, title: *uint8, unk: int64, unk1: int64) -> *void;
func @c_function glfwTerminate();
func @c_function glfwMakeContextCurrent(window: *void);
func @c_function glfwWindowShouldClose(window: *void) -> bool;
func @c_function glfwSwapBuffers(window: *void);
func @c_function glfwPollEvents();

// OpenGL
typealias GLenum     = uint32;
typealias GLboolean  = uint8;
typealias GLbitfield = uint32;
typealias GLbyte     = int8;
typealias GLshort    = int16;
typealias GLint      = int32;
typealias GLsizei    = int32;
typealias GLubyte    = uint8;
typealias GLushort   = uint16;
typealias GLuint     = uint32;
typealias GLfloat    = float;
typealias GLclampf   = float;
typealias GLdouble   = double;
typealias GLclampd   = double;
typealias GLvoid     = void;

let GL_CURRENT_BIT         : GLbitfield = 0x00000001;
let GL_POINT_BIT           : GLbitfield = 0x00000002;
let GL_LINE_BIT            : GLbitfield = 0x00000004;
let GL_POLYGON_BIT         : GLbitfield = 0x00000008;
let GL_POLYGON_STIPPLE_BIT : GLbitfield = 0x00000010;
let GL_PIXEL_MODE_BIT      : GLbitfield = 0x00000020;
let GL_LIGHTING_BIT        : GLbitfield = 0x00000040;
let GL_FOG_BIT             : GLbitfield = 0x00000080;
let GL_DEPTH_BUFFER_BIT    : GLbitfield = 0x00000100;
let GL_ACCUM_BUFFER_BIT    : GLbitfield = 0x00000200;
let GL_STENCIL_BUFFER_BIT  : GLbitfield = 0x00000400;
let GL_VIEWPORT_BIT        : GLbitfield = 0x00000800;
let GL_TRANSFORM_BIT       : GLbitfield = 0x00001000;
let GL_ENABLE_BIT          : GLbitfield = 0x00002000;
let GL_COLOR_BUFFER_BIT    : GLbitfield = 0x00004000;
let GL_HINT_BIT            : GLbitfield = 0x00008000;
let GL_EVAL_BIT            : GLbitfield = 0x00010000;
let GL_LIST_BIT            : GLbitfield = 0x00020000;
let GL_TEXTURE_BIT         : GLbitfield = 0x00040000;
let GL_SCISSOR_BIT         : GLbitfield = 0x00080000;
let GL_ALL_ATTRIB_BITS     : GLbitfield = 0xFFFFFFFF;

let GL_POINTS              : GLenum = 0x0000;
let GL_LINES               : GLenum = 0x0001;
let GL_LINE_LOOP           : GLenum = 0x0002;
let GL_LINE_STRIP          : GLenum = 0x0003;
let GL_TRIANGLES           : GLenum = 0x0004;
let GL_TRIANGLE_STRIP      : GLenum = 0x0005;
let GL_TRIANGLE_FAN        : GLenum = 0x0006;
let GL_QUADS               : GLenum = 0x0007;
let GL_QUAD_STRIP          : GLenum = 0x0008;
let GL_POLYGON             : GLenum = 0x0009;

func @c_function glBegin(mode: GLenum);
func @c_function glEnd();
func @c_function glColor3f(r: GLfloat, g: GLfloat, b: GLfloat);
func @c_function glVertex3f(x: GLfloat, y: GLfloat, z: GLfloat);

func @c_function glClearColor(r: GLclampf, g: GLclampf, b: GLclampf, a: GLclampf);
func @c_function glClear(bits: GLbitfield);


func read_entire_file(path: string) -> string {
	// @FixMe this only works if path points to a constant string
	var file = fopen(path.data, "rb".data);
	if file == null return "";

	fseek(file, 0, SEEK_END);
	var length = ftell(file);
	fseek(file, 0, SEEK_SET);

	printf("File length: %d\n".data, length);

	var mem = cast(c_string) malloc(length);
	fread(mem, 1, length, file);
	// @TODO verify fread success

	fclose(file);

	var result: string;
	result.data = mem;
	result.length = length;
	return result;
}

func add_vertex(array: *[..] float, v0: float, v1: float, v2: float) {
	array_add(array, v0);
	array_add(array, v1);
	array_add(array, v2);
}

func main() {
	glfwInit();

	var array: [..] float;
	add_vertex(*array,  0,  1, 0);	
	add_vertex(*array,  1, cast(float) -1, 0);
	add_vertex(*array, cast(float) -1, cast(float) -1, 0);

	printf("array.count    : %d\n".data, array.count);
	printf("array.allocated: %d\n".data, array.allocated);

	var window = glfwCreateWindow(1920, 1080, "Hello, Sailor!".data, 0, 0);
	
	printf("String length: %d\n".data, c_style_strlen("Hello".data));

	var contents = read_entire_file("test_file.txt"); // @Leak
	printf("File contents: %.*s\n".data, contents.length, contents.data);

	glfwMakeContextCurrent(window);

	while glfwWindowShouldClose(window) == false {
		glClearColor(0, 0, 0, 1);
		glClear(GL_COLOR_BUFFER_BIT);

		glBegin(GL_TRIANGLES);
		var i: int64 = 0;
		while i < array.count {
			glVertex3f(array[i+0], array[i+1], array[i+2]);
			i = i + 3;
		}
		glEnd();

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glfwTerminate();
}

let NEW_MEM_CHUNK_ELEMENT_COUNT = 16;

func array_reserve(array: *[..] float, _amount: int) {
	typealias T = float;

	var amount = _amount;
	if amount <= 0
		amount = NEW_MEM_CHUNK_ELEMENT_COUNT;

	var new_mem = cast(*T) malloc(amount * sizeof(T));

	if array.data != null {
		memcpy(new_mem, array.data, cast(size_t) (array.count * sizeof(T)) );
		free(array.data);
	}

	array.data = new_mem;
	array.allocated = amount;
}

func array_resize(array: *[..] float, _amount: int) {
	array_reserve(array, _amount);
	array.count = _amount;
}

func array_add(array: *[..] float, item: float) {
	if (array.count+1 >= array.allocated) array_reserve(array, cast(int) array.allocated + NEW_MEM_CHUNK_ELEMENT_COUNT);

	array.count = array.count + 1;
	(<<array)[array.count-1] = item;
}

func array_reset(array: *[..] float) {
	array.count = 0;
	array.allocated = 0;

	if array.data != null free(array.data);
	array.data = null;
}

func test_loops() {
	while true {
		while true {

		}
	}
}