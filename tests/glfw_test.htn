
#load "Array.htn";
#load "GLFW.htn";
#load "OpenGL.htn";
#load "LibC.htn";

// htn stuff

func to_c_string(input: string) -> c_string {
	var data: c_string = cast(c_string) malloc(cast(size_t) input.length + 1);
	memcpy(data, input.data, cast(size_t) input.length);
	data[input.length] = 0;
	return data;
}

func c_style_strlen(input: c_string) -> int64 {
	var cursor = input;
	while <<cursor != 0 {
		cursor = cursor + 1;
	}

	return cast(int64) (cursor - input);
}

func to_string(input: c_string) -> string {
	var s: string;
	s.data   = input;
	s.length = c_style_strlen(input);
	return s;
}

func split(input: string, delim: uint8) -> [] string {
	var start = 0;
	var cursor = 0;

	var output: [..] string;

	while cursor < input.length {
		if input[cursor] == delim {
			var o: string;
			o.data = input.data + start;
			o.length = cursor - start;
			array_add(*output, o);

			start = cursor + 1;
		}

		cursor = cursor + 1;
	}

	var o: string;
	o.data = input.data + start;
	o.length = cursor - start;
	array_add(*output, o);

	var static: [] string;
	static.data = output.data;
	static.count = output.count;
	return static;
}

func get_lines(input: string) -> [] string {
	return split(input, '\n');
}

func read_entire_file(path: string) -> string {
	// @FixMe this only works if path points to a constant string
	var file = fopen(path.data, "rb".data);
	if file == null return "";

	fseek(file, 0, SEEK_END);
	var length = ftell(file);
	fseek(file, 0, SEEK_SET);

	printf("File length: %d\n".data, length);

	var mem = cast(c_string) malloc(length);
	fread(mem, 1, length, file);
	// @TODO verify fread success

	fclose(file);

	var result: string;
	result.data = mem;
	result.length = length;
	return result;
}

struct Vector3 {
	var x: float;
	var y: float;
	var z: float;
}

func make_Vector3(x: float, y: float, z: float) -> Vector3 {
	var v: Vector3;
	v.x = x;
	v.y = y;
	v.z = z;
	return v;
}

struct Model {
	var vertices:   [..] Vector3;
	var normals:    [..] Vector3;
	var tex_coords: [..] Vector3;
}

func get_float(input: string) -> float {
	var c_str: [256] uint8;
	if input.length >= 256 return 0;

	memcpy(c_str.data, input.data, cast(size_t) input.length);
	c_str[input.length] = 0;

	var value = atof(c_str.data);
	return cast(float) value; 
}

func get_int(input: string) -> int32 {
	var c_str: [256] uint8;
	if input.length >= 256 return 0;

	memcpy(c_str.data, input.data, cast(size_t) input.length);
	c_str[input.length] = 0;

	var value = atoi(c_str.data);
	return value; 
}

func load_obj(path: string) -> Model {
	var data = read_entire_file(path);

	var lines = get_lines(data);
	var model: Model;

	var vertices:   [..] Vector3;
	var normals:    [..] Vector3;
	var tex_coords: [..] Vector3;

	// printf("char: %d\n".data, ' ');
	for lines {
		var splits = split(it, ' ');

		// printf("LINE: '%.*s'\n".data, it.length, it.data);
		for splits {
			// printf("SPLIT: '%.*s'\n".data, it.length, it.data);
		}

		// @Cleanup continue keyword
		if splits.count == 0 {
			// do nothing
		} else if splits[0] == "v" {
			var x = get_float(splits[1]);
			var y = get_float(splits[2]);
			var z = get_float(splits[3]);
			array_add(*vertices, make_Vector3(x, y, z));
		} else if splits[0] == "vn" {
			var x = get_float(splits[1]);
			var y = get_float(splits[2]);
			var z = get_float(splits[3]);
			array_add(*normals, make_Vector3(x, y, z));
		} else if splits[0] == "f" {
			{
				var sub = split(splits[1], '/');
				var vi = get_int(sub[0]);
				var ni = get_int(sub[2]);
				array_add(*model.vertices, vertices[vi - 1]);
				array_add(*model.normals,  normals[ni - 1]);
			}

			{
				var sub = split(splits[2], '/');
				var vi = get_int(sub[0]);
				var ni = get_int(sub[2]);

				array_add(*model.vertices, vertices[vi - 1]);
				array_add(*model.normals,  normals[ni - 1]);
			}

			{
				var sub = split(splits[3], '/');
				var vi = get_int(sub[0]);
				var ni = get_int(sub[2]);

				array_add(*model.vertices, vertices[vi - 1]);
				array_add(*model.normals,  normals[ni - 1]);
			}
		}
	}

	free(lines.data);
	free(data.data);
	return model;
}

func perspective(fov: float, aspect: float, near: float, far: float) {
	var fh = tan(fov) * near;
	var fw = fh * aspect;

	glFrustum(-fw, fw, -fh, fh, near, far);
}

func main() {
	glfwInit();

	var model = load_obj("monkey.obj");

	var array: [..] Vector3;
	array_add(*array, make_Vector3( 0, 1, 0));
	array_add(*array, make_Vector3( 1,-1, 0));
	array_add(*array, make_Vector3(-1,-1, 0));

	for 0..array.count-1 {
		var a = array[it];
		printf("For: %d, (%f, %f, %f).\n".data, it, a.x, a.y, a.z);
	}

	for array {
		printf("For (round 2): %d, (%f, %f, %f)\n".data, it_index, it.x, it.y, it.z);
	}

	printf("array.count    : %d\n".data, array.count);
	printf("array.allocated: %d\n".data, array.allocated);

	var window = glfwCreateWindow(1920, 1080, "Hello, Sailor!".data, 0, 0);
	
	printf("String length: %d\n".data, c_style_strlen("Hello".data));

	var contents = read_entire_file("test_file.txt"); // @Leak
	printf("File contents: %.*s\n".data, contents.length, contents.data);

	glfwMakeContextCurrent(window);

	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	glEnable(GL_DEPTH_TEST);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	var width: float = 1920;
	var height: float = 1080;
	perspective(1, width / height, 1, 1000);

	glMatrixMode(GL_MODELVIEW);
	
	var n: float = 0;

	while glfwWindowShouldClose(window) == false {
		glClearColor(0, 0, 0, 1);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		glLoadIdentity();
		glTranslatef(0, 0, -3);
		// glRotatef(n, 0, 1, 0);

		glBegin(GL_TRIANGLES);
		for 0..model.vertices.count-1 {
			var v = model.vertices[it];
			var n = model.normals[it];
			glVertex3f(v.x, v.y, v.z);
			glNormal3f(n.x, n.y, n.z);
		}
		glEnd();

		n = n + (cast(float)1 / 4);

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	glfwTerminate();
}
